# Definindo fun√ß√µes em R

A capacidade de escrever fun√ß√µes otimiza a execu√ß√£o de tarefas repetitivas e torna o usu√°rio um desenvolvedor de conte√∫do.

## Aspectos gerais das fun√ß√µes em R

Uma fun√ß√£o √© um objeto capaz de realizar uma a√ß√£o. Por exemplo, a fun√ß√£o `mean()` obt√©m a m√©dia de um vetor num√©rico e a fun√ß√£o `sqrt()` realiza o c√°lculo da raiz quadrada de cada elemento de um vetor num√©rico.

-   Fun√ß√µes podem ser usadas de forma encadeada. O resultado de uma fun√ß√£o √© usado pela fun√ß√£o mais externa:

```{r eval=FALSE}
# O resultado da fun√ß√£o unique() √© usado pela fun√ß√£o length()
length(unique(mtcars$cyl))
```

## Fazendo a correspond√™ncia dos argumentos nas fun√ß√µes

A correspond√™ncia dos argumentos de uma fun√ß√£o pode ser feita por meio do **nome do argumento** ou por meio da **posi√ß√£o**. Vamos tomar como exemplo a fun√ß√£o `rnorm()`, que gera um vetor de *n* elementos que possui valores que obedecem √† distribui√ß√£o normal.

A fun√ß√£o possui 3 argumentos: `n` (tamanho do vetor a ser criado), `mean` (m√©dia da distribui√ß√£o) e `sd` (desvio padr√£o da distribui√ß√£o), nesta ordem. Se os nome dos argumentos n√£o forem definidos na chamada da fun√ß√£o, ela assumir√° que o primeiro argumento corresponde ao *n*, o segundo ao *mean* e o terceiro ao *sd*.

Vamos criar um vetor de 100 elementos com m√©dia 1 e desvio padr√£o 2.

```{r}
# Argumentos da fun√ß√£o rnorm
args(rnorm)
```

```{r eval=FALSE}
# Fazendo a correspond√™ncia pela posi√ß√£o dos argumentos 
rnorm(100, 1, 2) 
```

```{r eval=FALSE}
# Fazendo a correspond√™ncia pelo nome dos argumentos
rnorm(mean = 1, n = 100, sd = 2)
```

Ambas as utiliza√ß√µes ir√£o gerar e mesmo resultado.

Observe, ainda, que as fun√ß√µes podem apresentar argumentos que j√° possuem uma valor pr√©-definido. Na fun√ß√£o `rnorm()`, os argumentos `mean()` e `sd()` possuem valores pr√©-definidos.

```{r eval=FALSE}
# A fun√ß√£o ir√° executar mesmo sem o fornecimento dos outros argumentos.
rnorm(n = 100) 
```

Entretanto, observe que o argumento `n` n√£o possui valor pr√©-definido. A aus√™ncia deste argumento impossibilita a execu√ß√£o da fun√ß√£o.

```{r error=TRUE}
rnorm()
```

## Anatomia das fun√ß√µes em R

As fun√ß√µes possuem tr√™s elementos primordiais:

-   Argumentos: par√¢metros que possibilitam a execu√ß√£o da a√ß√£o. Ao definir a fun√ß√£o, os argumentos podem assumir qualquer nome;
-   Corpo: sequ√™ncia de passos para resultar no objetivo da fun√ß√£o;
-   Ambiente: quando uma fun√ß√£o √© definida, ela cria um ambiente p≈ïoprio, onde as vari√°veis criadas dentro dela possuem valores pr√≥prios.

### Definindo fun√ß√µes

Algumas propriedades das fun√ß√µes:

-   A fun√ß√£o `function()` cria fun√ß√µes definidas pelo pr√≥prio usu√°rio:

```{r}
my_fun <- function(arg1, arg2) { # Argumentos
    # Corpo da fun√ß√£o
}
```

-   As fun√ß√µes podem ter uma quantidade indeterminada de argumentos e, inclusive, n√£o apresentar argumentos:

```{r}
# Imprime 12. N√£o possui argumentos.
f <- function() { 
      12
}
f()
```

```{r}
# Simplesmente imprime "BU!" com qualquer argumento.
f1 <- function(x) { 
      "BU!"
}
f1()
```

-   Os argumentos das fun√ß√µes podem apresentar um valor pr√©-definido:

```{r}
# y possui um valor pr√©-definido
f2 <- function(x, y = 10) { 
      x + y
}
f2(2)
f2(2, 4)
```

-   Quando definimos um objeto dentro de uma fun√ß√£o e este representa o resultado final da fun√ß√£o, √© necess√°rio retornar seu valor. Para isso, podemos usar a fun√ß√£o `return()` ou `print()`:

```{r}
# Imprimir o resultado calculado
f3 <- function(a, b) {
      res <- c()
      res[1] <- a^2
      res[2] <- b + 1
      print(res) 
}
f3(2, 4)
```

-   Func√µes podem existir dentro de outras fun√ß√µes:

```{r}
make.power <- function(n) {
      pow <- function(x) {
            x^n
      }
      pow
}

cube <- make.power(3)
square <- make.power(2)

cube(3)
square(2)
```

## Ambientes e escopo das fun√ß√µes

Antes de qualquer coisa, precisamos entender o conceito de vari√°veis livres. As vari√°veis livres s√£o vari√°veis que n√£o s√£o argumentos das fun√ß√µes e nem foram definidas dentro da fun√ß√£o (no escopo da fun√ß√£o). As regras de escopo definem como o R ir√° tentar buscar o valor correspondente a essa vari√°vel livre. Por exemplo:

```{r}
fun <- function(x, y) {
    x + y + z
}
```

A fun√ß√£o acima possui a vari√°vel *z*, por√©m ela n√£o foi definida nem como argumento nem no escopo da fun√ß√£o.

Ambientes correspondem a um conceito abstrato para definir um conjunto de objetos. O ambiente mais usado interativamente pelo usu√°rio √© o *Global Environment* ou ambiente global, que guarda as objetos e fun√ß√µes que constru√≠mos em uma sess√£o do R. Quando estamos trabalhando no console e queremos obter o valor de um objeto, o R ir√° procurar pelo objeto primeiramente no ambiente global e, se n√£o encontrar, ir√° procurar nos outros ambientes.

Para se ter uma ideia de quantos e quais os ambientes podem existir, podemos usar a fun√ß√£o `search()`.

```{r}
search()
```

Tendo em vista a ideia de ambiente, consideremos a fun√ß√£o `fun()` definida anteriormente. O valor da vari√°vel *z* √© buscado inicialmente no escopo da fun√ß√£o, em seguida no ambiente global e, se n√£o encontrado, √© buscado nos outros ambientes. Se, ap√≥s o t√©rmino da busca, o valor desta vari√°vel n√£o for encontrado, a fun√ß√£o retornar√° um erro:

```{r echo=FALSE, error=FALSE}
rm(z)
```

```{r error=TRUE}
fun <- function(x, y) {
    x + y + z
}
fun(1, 3)
```

Mais exemplos:

```{r echo=FALSE, error=FALSE}
rm(z)
```

```{r error=TRUE}
f4 <- function(x, y) {              
      x^2 + y/z
}
f4(2, 4)
```

No caso a seguir, o valor da vari√°vel *z* √© definido no ambiente global e possibilita a execu√ß√£o da fun√ß√£o.

```{r}
z <- 3
f4 <- function(x, y) {              
      x^2 + y/z
}
f4(2, 4)
```

## Outros exemplos

Criando uma fun√ß√£o para adicionar dois n√∫meros:

```{r}
# x e y s√£o os argumentos da fun√ß√£o definida
# O que a fun√ß√£o faz: adiciona dois n√∫meros
add_num <- function(x, y) {
    x + y 
}
add_num(x = 2, y = 3)
```

Criando uma fun√ß√£o para calcular a m√©dia de um vetor num√©rico:

```{r}
calc_media <- function(vetor) {
    sum(vetor)/length(vetor)
}
calc_media(c(1, 2, 3, 4))
```

Criando uma fun√ß√£o que obtenha os valores extremos de um vetor num√©rico:

```{r}
# Ap√≥s criar uma vari√°vel dentro do escopo da fun√ß√£o, devemos retornar o valor da vari√°vel.
obter_extremos <- function(vetor) {
    res <- c(min(vetor, na.rm = TRUE), max(vetor, na.rm = TRUE))
    print(res)  
}
obter_extremos(c(1, 2, 3, 4))
```

## Desafio

::: callout-tip
## Pratique sem IA!

Os desafios a seguir foram criados para ajud√°-lo a desenvolver suas habilidades de forma independente.\
Evite o uso de Intelig√™ncia Artificial e tente resolver os problemas por conta pr√≥pria.\
Aprender com a pr√°tica fortalecer√° seu racioc√≠nio e aprofundar√° seu conhecimento! üöÄ
:::

1.  Crie uma fun√ß√£o chamada de 'f1' que possua uma outra fun√ß√£o 'f2', esta definida dentro do escopo de 'f1'.

A fun√ß√£o interna ('f2') deve fazer duas coisas: - Imprimir no console o ambiente atual com a fun√ß√£o `environment()` - Imprimir os objetos pertencentes ao seu escopo com a fun√ß√£o `ls()`.

A fun√ß√£o externa ('f1') deve fazer 3 coisas: - Deve chamar a fun√ß√£o 'f2' - Imprimir no console o ambiente atual com a fun√ß√£o `environment()` - Imprimir os objetos pertencentes ao seu escopo com a fun√ß√£o `ls()`.

Uma vez definidas estas fun√ß√µes, chame a fun√ß√£o externa e responda: os ambientes exibidos s√£o os mesmos? Justifique.

```{r}
#
```

2.  Com base nas regras de escopo do R, justifique o resultado das chamadas das fun√ß√µes abaixo:

```{r}
# Ex.:1

x <- 12
f1 <- function(y) {
  x <- 10
  f2 <- function() {
    print(x + y)
  }
  f2()
}

f1(4)

# Ex.:2
z <- 10
f3 <- function(x, y) {
  x * y * z
}
f3(1, 2)
```

3.  Leia o arquivo network.txt. Ele ser√° usado nas quest√µes 1 a 3. Este conjunto de dados representa uma rede de intera√ß√£o entre prote√≠nas, cujos nomes aparecem nas colunas `node1*` e `node2*`. As demais colunas representam scores usados para inferir a for√ßa da intera√ß√£o. A coluna combined_score representa o score combinado destas diferentes fontes e representa a confian√ßa total para cada intera√ß√£o.

Como este arquivo representa uma rede, cada linha do dataframe lido ser√° uma intera√ß√£o entre duas prote√≠nas. Ou seja, os n√≥s da rede est√£o representados nas colunas `node1*` e `node2*` e as arestas s√£o as intera√ß√µes entre node1\* e `node2*`.

```{r}
network <- read.table("data/network.txt", sep = "\t", stringsAsFactors = F, header = T)
```

a)  Crie a fun√ß√£o 'filtrar_rede' para selecionar as intera√ß√µes da rede com score combinado maior que 0.700.

-   Input: dataframe da rede 'network'.
-   Output: dataframe filtrado com as intera√ß√µes maiores que 0.700 e contendo apenas 3 colunas (node1, node2 e combined_score) Ex:

```{r}
 # nrow(filtrar_rede(network = network))
 # [1] 948
```

b)  Crie a fun√ß√£o 'vizinhos' que calcule a conectividade (quantidade de intera√ß√µes) de um determinado n√≥ da rede e quais s√£o os n√≥s que se conectam com ele.

-   Input: dois argumentos: nome da prote√≠na e o dataframe onde ser√° feita a opera√ß√£o
-   Output: Imprimir no console a conectividade do n√≥ escolhido e quais s√£o seus vizinhos. Ex:

```{r}
 # vizinhos(symbol = "NGF", network = network)
 # O gene  NGF tem  16 vizinhos
 # PIK3R1 CASP6 IKBKB NTRK1 NFKBIA PIK3CB NFKB1 PIK3R2 BAD PIK3CA CASP3 MYD88 CHUK RELA IRAK1 IKBKG
```

c)  Ainda sobre o dataset 'network', crie uma fun√ß√£o que receba como argumentos o nome de um gene, o dataframe da rede e o score de homologia (coluna homology), e retorne um dataframe que mostre as intera√ß√µes deste gene (colunas 'node1' e 'node2') para um score de homologia maior ou igual um determinado valor. Use 0.5 como um valor padr√£o para este limiar de score de homologia.

-   Input: homologia(symbol = "CHUK", network = network)

-   Output: \> homologia("CHUK", network)

    node1 node2 homology

    24 CHUK IRAK4 0.625

    271 CHUK RIPK1 0.525

    521 CHUK MAP3K14 0.515

    950 AKT2 CHUK 0.656

    1158 CHUK AKT3 0.638

    1182 CHUK AKT1 0.656

    1400 CHUK IKBKB 0.936

    1712 CHUK CHEK1 0.679

```{r}
#
```

d)  Importe o arquivo `contents/data/COGs.RData`, dispon√≠vel no sigaa, que foi usado na aula de Importa√ß√£o e Exporta√ß√£o de dados. Use o dataframe `contents/data/cog.human.data` load("COGs.RData")

Fa√ßa uma fun√ß√£o que retorne o n√∫mero de grupos de ort√≥logos (identificadores da coluna cog_id) de uma determinada esp√©cie (coluna spp_id)

-   Input: dois argumentos - identificador da esp√©cie e o dataframe
-   Output: n√∫mero de COGs do organismo Ex:

```{r}
# > contar_cogs(spp = 3702, df = cog.human.data)
# [1] 4367
```

e)  Considere o dataset 'attitude'. Escreva uma fun√ß√£o que receba como argumento o nome de uma das colunas e retorne um dataframe contendo o valor da m√©dia, mediana, soma das observa√ß√µes, e quantidade de valores faltantes (NA) na coluna:

-   Input: estatisticas(attitude, "rating")
-   Output: dataframe com os resultados Ex:

```{r}
# > estatisticas(attitude, "rating")
# media mediana soma n_na
# 1 64.63333    65.5 1939    0
```
