# Objetos em R

## Vetores

Função de concatenação `c()`:

```{r}
number<-c(1, 2, 3, 4, 5)                       #numeric
letter<-c("x", "y", "z", "w", "j")             #character
logico<- c(TRUE, FALSE, FALSE, TRUE, FALSE)    #logical
seq<-1:10       
complexo<-4i
```

A função `class()` pode ser usada para acessar a classe de um determinado objeto:

```{r}
class(number)
```

### Hierarquia de classes

Vetores comportam apenas uma classe de elementos. Quando um vetor é criado com valores pertecentes a classes distintas, é feita uma conversão implícita. Um valor `logical` é convertido para `numeric`, e um valor `numeric` é convertido para `character`:

```{r}
class(c(1, 2, 3))
class(c("1", "2", "3"))
class(c(TRUE, FALSE, FALSE))
class(c("TRUE", "FALSE", "FALSE"))
class(c(1, "a", TRUE))
class(c(1, "a"))
class(c(1, T))
class(c("a", T))
```

Com esta hierarquia, é possível somar valores lógicos, sendo `TRUE` equivalente a 1[^03_objects-1], e `FALSE` equivalente a 0:

[^03_objects-1]: na conversão de valores numéricos para lógicos, 0 é convertido para FALSE e qualquer outro valor é convertido em TRUE

```{r}
logical<- c(TRUE, FALSE, FALSE, TRUE, FALSE)
sum(logico)
```

Uma conversão explícita pode ser feita com as funções `as.<nome da classe>`:

```{r}
x<-0:10
x
class(x)
a<-as.numeric(x)
a
class(a)
b<-as.character(x)
b
class(b)
c<-as.logical(x)
c
class(c)
```

### Valores não disponíveis ou impossíveis

Valores não disponíveis são representados por `NA` (*Not Available*), e valores impossíveis, como o resultado de uma divisão por 0, são representados por `NaN` (*Not a Number*).

```{r}
x<-c(1, 2, 3, NA)
y<-c("a", "b", "c", NA)
is.na(x)
w<-rep(NA, 10)
w
class(w)
z<-rep(NA_integer_, 10)
z
class(z)
a <- c(1, 3, NA, 7, 9)
sum(a)
sum(a, na.rm=TRUE)
```

### Atributos de objetos

Todos os objetos possuem atributos:

```{r}
x<-1:5
x
length(x)
dim(x)
attributes(x)
names(x)<-c("a", "b", "c", "d", "e")
x
attributes(x)
```

### Fator

Um vetor da classe `factor` é um vetor categórico que possui o atributo `levels`:

```{r}
x<-factor(c("s", "n", "n", "s", "s"))
z<-factor(c("alto", "baixo", "medio"))
x
z
```

### Trabalhando com vetores

No R as operações são vetorizadas:

```{r}
x<-1:5
x
y<-6:10
y
```

Soma dos valores de ambos os vetores

```{r}
x+y
```

Podemos multiplicar um vetor por um número:

```{r}
x*2               
x^2
z<-c(x,y)
z
z+x
w<-1:3
w+x
l<-c(T, T, F, T, F, F)
l/2
```

Usamos `[]` para acessar elementos de vetores:

```{r}
letter<-c("x", "y", "z", "w", "j")
# acessa o segundo elemento do vetor
letter[2]               
# podemos usar sequências de valores
letter[2:4]             
# usamos a função c() para valores não contíguos
letter[c(1, 4)]         
# usamos números negativos para excluir um ou mais valores
letter[-2]              
letter[c(-2, -5)]
# podemos criar índices numéricos
idx<-c(1, 4)            
letter[idx]
x<-1:10
# podemos usar operadores relacionais como filtros
x[x>7]                  
# também funciona com caracteres, levando em consideração a ordem lexicográfica
letter[letter>"k"]      
letter[letter<"k"]
letter=="z"
```

Funções para identificar valores extremos:

```{r}
# definindo uma semente para a geração de valores aleatórios
set.seed(1)
s<-sample(-1000:1000, 200)
# procura a posição do maior valor
which.max(s)            
# exibe o maior valor
max(s)
# exibe o menor valor
min(s)
# exibe o intervalo dos valores do vetor
range(s)
# cria um vetor lógico
s>0                     
# cria um vetor com as posições que satisfazem o comando
which(s>0)              
```

Funções de ordenamento:

```{r}
x<-c(3, 8, 2, 1, 5, 9, 7, 7, 3)
x
# ordena um vetor
sort(x)        
sort(x, decreasing = T)
# informa a ordem na qual cada elemento deve ser acessado para exibir o conteúdo do vetor em ordem crescente
order(x)                
# exibe o conteúdo do vetor de forma aleatória, e uma única vez, cada posição
sample(x)     
# elimina as replicatas
unique(x)
# exibe um vetor lógico referente à posição das replicatas
duplicated(x)           
```

## Matrizes

Matrizes são vetores bidimensionais que possuem o atributo dimensão. Por serem vetores, comportam apenas uma classe de elementos:

```{r}
x<-1:20
x
attributes(x)
m<-matrix(x, 4, 5)
m
attributes(m)
dim(x)<-c(4,5)
x
identical(x, m)
a<-1:5
b<--1:-5
c<-c(3, 6, 4, 9, 1)
# a função cbind() concatena colunas
m<-cbind(a, b, c)       
m
# a função rbind() concatena linhas  
m1<-rbind(a, b, c)
m1
# elementos são acessados pelos índices das duas dimenções [linha, coluna]
m[1,3]
# toda a linha
m[1, ]
m[2:3, ]
# atribuição
m[1,]<-NA
m
```

::: callout-important
Como são vetores, matrizes comportam somente uma classe de elementos
:::

## Arrays

Um `array` é um vetor que possui mais de duas dimensões:

```{r}
# criando um vetor multidimensional com 4 matrizes de 5 linhas e 10 colunas
ar<-array(1:200, c(5, 10, 4))
ar
# acessando a primeira matriz [linha, coluna, matriz]
ar[,,1]                          
```

## Strings

Conceitualmente, uma `string` é um vetor de caracteres[^03_objects-2]. Certas operações são recorrentes na manipulação de strings, como a inserção de conteúdo numa dada posição, substituição do conteúdo de uma porção do vetor, ou a busca de um determinado padrão:

[^03_objects-2]: independente da quantidade de caracteres o atributo length será sempre igual a 1

```{r}
x<-20:30
y<-1:4
# adiciona valores num vetor numa posição específica
append(x, y, after = 3)
# concatena dois vetores, converte em character
x<-paste("dt", 1:10, sep = "")     
x
```

Identificando expressões regulares (regex) numa string:

```{r}
x <- c("16_24cat", "25_34cat", "35_44catch", "45_54Cat", "55_104fat")
# identifica regex por posição
grep("cat", x)               
# o argumento value = T retorna os valores
grep("cat", x, value = T)           
# $ é um metacaractere que identifica o término da string
grep("cat$", x, ignore.case = T)    
# a função grepl() retorna um vetor lógico
grepl("cat$", x, ignore.case = T)
```

### Expressões regulares

| Metacaractere | Funcionalidade     |
|---------------|--------------------|
| \*            | 0 ou mais vezes    |
| \+            | uma ou mais vezes  |
| ?             | 0 ou 1 vez         |
| {n}           | exatamente n vezes |
| {n,}          | pelo menos n vezes |
| {n,m}         | entre n e m vezes  |
| \^            | início da string   |
| \$            | final da string    |

```{r}
strings <- c("a", "ab", "acb", "accb", "acccb", "accccb")
grep("acb", strings)
grep("ac*b", strings)
grep("ac+b", strings)
grep("ac?b", strings)
grep("ac{2}b", strings)
grep("ac{2,}b", strings)
grep("ac{2,3}b", strings)
```

## Listas

Listas são tipos especiais de vetores que comportam elementos de diferentes classes:

```{r}
a <- c(1, 3, NA, 7, 9)
b<-matrix(1:200, 20,10)
c<-"Gol do Gremio"
z<-factor(c("alto", "baixo", "medio"))
ls<-list(a, b, c, z)
# cada elemento da lista aparece com [[]]
ls                    
# a função vector() pode criar listas vazias
ls1<-vector("list", 5)   
ls1
```

### Trabalhando com listas

Listas podem ser acessadas com os operadores `[]`, `[[]]` e `$` (para listas nomeadas):

```{r}
# [] extrai uma lista
ls[1]        
# [[]] extrai o objeto interno
ls[[1]]           
class(ls[1])
class(ls[[1]])
# posição na lista e posição no elemento
ls[[c(1,2)]]      
ls[[2]][2,]
names(ls)<-c("Arilson", "Roger", "Paulo Nunes", "Jardel")
ls$Roger
```

## Data.frames

Um `data.frame` é um tipo especial de lista, onde todos os elementos devem possuir o mesmo length. Por ser uma lista, cada posição comporta elementos de diferentes classes. Do ponto de vista prático, o `data.frame` funciona como uma planilha bidimensional formado por vetores de mesmo tamanho, sendo cada vetor uma coluna:

```{r}
number<-c(1, 2, 3, 4, 5)
letter<-c("x", "y", "z", "w", "j")
logical<- c(TRUE, FALSE, FALSE, TRUE, FALSE)
seq<-1:10
dt<-data.frame(number, letter, logical)
class(dt)
# usamos $ para acessar as colunas de um data.frame
dt$letter               
# vetores de caracteres são interpretados como fatores
class(dt$letter)          
# argumento stringsAsFactors = F altera este comportamento padrão
dt<-data.frame(number, letter, logical, stringsAsFactors = F) 
dt$letter
class(dt$letter)
# data.frames possuem colnames e rownames como atributos
attributes(dt)                
colnames(dt)
row.names(dt)
# acessamos data.frames da mesma forma que matrizes
dt[5,2]                       
```

### Trabalhando com data.frames

Para acessar data.frames podemos usar os operadores `[]`, `[[]]` e `$`:

```{r}
dt<-data.frame(number=c(1, 2, 3, 4, 5),
               letter = c("x", "y", "z", "w", "j"),
               logical = c(TRUE, FALSE, FALSE, TRUE, FALSE))
# [[ ]] acessa cada coluna por posição
dt[[1]]              
# [ ] acessa as coordenadas [linha, coluna]
dt[,1]               
# $ acessa a coluna pelo nome
dt$number            
# carrega o data.frame mtcars
cars<-mtcars        
# mostra as 6 primeiras linhas
head(cars)          
# mostra as 6 ultimas linhas
tail(cars)
# data.frames possuem colnames e rownames
colnames(dt)
row.names(dt)
# podemos alterar colnames e rownames
row.names(dt)<-c("a", "b", "c", "d", "e")
# alterando apenas a posição 2
colnames(dt)[2]<-"letras"     
# podemos alterar valores específicos de um data.frame
dt[3,1]<-"10"
dt$logical<-as.numeric(dt$logical)
dt$letras<-NA
```

É possível verificar as ocorrencias de um data.frame em outro:

```{r}
biometria<-data.frame(nomes=c("Carlos", "Roberto", "Olivio", "Joel"),
                      altura=c(180, 187, 155, 168),
                      peso=c(80, 90, 98, 64))
biometria
esportes<-data.frame(nomes=c("Carlos", "Roberto", "Olivio", "Jomar"),
                     esportes=c("futebol", "remo", "sumo", "maratona"))
esportes
# retorna um vetor lógico
biometria$nomes %in% esportes$nomes
# pode ser usado como índice
idx<-biometria$nomes %in% esportes$nomes    
x<-biometria[idx,]
x
# ordenando data.frames por uma coluna
biometria<-biometria[with(biometria, order(altura)), ]
biometria
```

Unindo data.frames com a função `merge()`:

```{r}
# independe da ordem dos data.frames
# a busca é feita pelo nome, não pela ordem
# o resultado sempre virá em ordem alfabética
unido<-merge(biometria, esportes, by="nomes")
unido
# as informações não disponíveis são preenchidas por NA
# com todos os presentes no primeiro
unido<-merge(biometria, esportes, by="nomes", all.x=T)
unido
# com todos os presentes no segundo
unido<-merge(biometria, esportes, by="nomes", all.y=T)
unido
# com todos presentes
unido<-merge(biometria, esportes, by="nomes", all=T)
unido
```
